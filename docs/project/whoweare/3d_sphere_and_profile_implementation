# 3D 구체 프로필 카드 구현 가이드

## 개요
투명한 유리구 내부에 수직으로 떠 있는 프로필 카드를 구현하고, 클릭 시 2D 카드로 변환되는 인터랙션을 만드는 방법입니다.

## 1. 구체 안의 프로필 카드 구현

### 1.1 기본 구조
```javascript
function createProfileSphere(memberData) {
    // 메인 그룹 컨테이너
    const group = new THREE.Group();
    group.userData = memberData;
    
    // 1. 투명한 유리구 생성
    const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
    const sphereMaterial = new THREE.MeshPhysicalMaterial({
        color: memberData.color,
        metalness: 0.1,
        roughness: 0.1,
        transparent: true,
        opacity: 0.2,  // 매우 투명하게
        clearcoat: 1.0,
        clearcoatRoughness: 0.0,
        side: THREE.BackSide  // 중요: 내부가 보이도록 BackSide 렌더링
    });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    group.add(sphere);
    
    // 2. 내부 글로우 효과
    const glowGeometry = new THREE.SphereGeometry(1.95, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: memberData.color,
        transparent: true,
        opacity: 0.1,
        side: THREE.BackSide
    });
    const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
    group.add(glowSphere);
    
    // 3. 수직 프로필 카드 생성
    const profileGroup = new THREE.Group();
    
    // 카드 배경
    const cardGeometry = new THREE.PlaneGeometry(2.5, 3);
    const cardMaterial = new THREE.MeshBasicMaterial({
        color: 0x1a1a1a,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
    });
    const card = new THREE.Mesh(cardGeometry, cardMaterial);
    profileGroup.add(card);
```

### 1.2 프로필 카드 콘텐츠 생성
```javascript
// Canvas를 사용한 프로필 카드 디자인
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 512;
canvas.height = 640;

// 반투명 흰색 배경
ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
ctx.fillRect(0, 0, 512, 640);

// 프로필 사진 원형 영역
const centerX = 256;
const photoY = 150;
ctx.fillStyle = '#' + memberData.color.toString(16).padStart(6, '0');
ctx.beginPath();
ctx.arc(centerX, photoY, 80, 0, Math.PI * 2);
ctx.fill();

// 원형 테두리
ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
ctx.lineWidth = 4;
ctx.stroke();

// 이니셜
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 60px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(memberData.initials, centerX, photoY);

// 이름
ctx.fillStyle = '#1a1a1a';
ctx.font = 'bold 40px Arial';
ctx.fillText(memberData.name, centerX, 300);

// 역할
ctx.fillStyle = '#' + memberData.color.toString(16).padStart(6, '0');
ctx.font = '28px Arial';
ctx.fillText(memberData.role, centerX, 350);

// 구분선
ctx.strokeStyle = '#' + memberData.color.toString(16).padStart(6, '0');
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(156, 390);
ctx.lineTo(356, 390);
ctx.stroke();

// 명언 (여러 줄 처리)
ctx.fillStyle = '#666';
ctx.font = 'italic 24px Arial';
wrapText(ctx, memberData.quote, centerX, 440, 320, 35);

// 텍스처 적용
const profileTexture = new THREE.CanvasTexture(canvas);
const profileMaterial = new THREE.MeshBasicMaterial({
    map: profileTexture,
    transparent: true,
    side: THREE.DoubleSide
});
const profilePlane = new THREE.Mesh(
    new THREE.PlaneGeometry(2.5, 3.2),
    profileMaterial
);
profilePlane.position.z = 0.1;
profileGroup.add(profilePlane);
```

### 1.3 애니메이션 효과
```javascript
// 애니메이션 루프에서
function animate() {
    // 구체는 회전
    sphere.rotation.y += 0.005;
    
    // 프로필 카드는 항상 카메라를 향해 정면 유지
    if (sphere.userData.profileGroup) {
        sphere.userData.profileGroup.rotation.y = -sphere.rotation.y;
    }
    
    // 파티클 효과 (선택사항)
    if (sphere.userData.particles) {
        sphere.userData.particles.rotation.y += 0.02;
        sphere.userData.particles.position.y = Math.sin(Date.now() * 0.001) * 0.2;
    }
}
```

## 2. 클릭 시 2D 변환 효과

### 2.1 클릭 이벤트 처리
```javascript
function onMouseClick(event) {
    if (isAnimating) return;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(sphereObjects, true);
    
    if (intersects.length > 0) {
        const clickedObject = intersects[0].object.parent;
        if (clickedObject.userData && clickedObject.userData.id) {
            openProfile(clickedObject.userData);
        }
    }
}
```

### 2.2 구체 확장 애니메이션
```javascript
function openProfile(memberData) {
    isAnimating = true;
    
    const sphere = sphereObjects.find(s => s.userData.id === memberData.id);
    selectedSphere = sphere;
    
    // 애니메이션 타임라인
    const expandTimeline = {
        scale: 1,
        opacity: 0.2  // 현재 투명도
    };
    
    const animateSphere = () => {
        // 점진적으로 확대하면서 더 투명하게
        expandTimeline.scale += (2 - expandTimeline.scale) * 0.1;
        expandTimeline.opacity += (0 - expandTimeline.opacity) * 0.1;
        
        sphere.scale.set(expandTimeline.scale, expandTimeline.scale, expandTimeline.scale);
        sphere.children[0].material.opacity = expandTimeline.opacity;
        
        if (expandTimeline.scale > 1.9) {
            // 애니메이션 완료 시 2D 카드 표시
            showProfileCard(memberData);
            return;
        }
        
        requestAnimationFrame(animateSphere);
    };
    
    animateSphere();
}
```

### 2.3 2D 프로필 카드 표시
```javascript
function showProfileCard(memberData) {
    const card = document.getElementById('profileCard');
    const colorHex = '#' + memberData.color.toString(16).padStart(6, '0');
    
    // 카드 스타일 설정
    card.style.borderColor = colorHex;
    
    // 카드 내용 업데이트
    document.getElementById('profilePhoto').style.background = colorHex;
    document.getElementById('profilePhoto').textContent = memberData.initials;
    document.getElementById('profileName').textContent = memberData.name;
    document.getElementById('profileName').style.color = colorHex;
    document.getElementById('profileRole').textContent = memberData.role;
    document.getElementById('profileQuote').textContent = memberData.quote;
    document.getElementById('profileStory').textContent = memberData.story;
    
    // 카드 표시 애니메이션
    card.classList.add('active');
    
    setTimeout(() => {
        isAnimating = false;
    }, 600);
}
```

### 2.4 CSS 트랜지션 효과
```css
.profile-card {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0) rotateY(90deg);
    transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    opacity: 0;
    visibility: hidden;
}

.profile-card.active {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1) rotateY(0deg);
}
```

### 2.5 카드 닫기 및 복원
```javascript
function closeProfile() {
    const card = document.getElementById('profileCard');
    card.classList.remove('active');
    
    if (selectedSphere) {
        const resetTimeline = {
            scale: selectedSphere.scale.x,
            opacity: selectedSphere.children[0].material.opacity
        };
        
        const animateReset = () => {
            // 원래 크기와 투명도로 복원
            resetTimeline.scale += (1 - resetTimeline.scale) * 0.1;
            resetTimeline.opacity += (0.2 - resetTimeline.opacity) * 0.1;
            
            selectedSphere.scale.set(resetTimeline.scale, resetTimeline.scale, resetTimeline.scale);
            selectedSphere.children[0].material.opacity = resetTimeline.opacity;
            
            if (resetTimeline.scale < 1.1) {
                selectedSphere = null;
                return;
            }
            
            requestAnimationFrame(animateReset);
        };
        
        animateReset();
    }
}
```

## 3. 핵심 구현 포인트

### 3.1 투명도와 가시성
- 구체의 `side: THREE.BackSide` 설정이 핵심
- `opacity: 0.2` 정도로 매우 투명하게 설정
- 내부 글로우 레이어로 깊이감 추가

### 3.2 프로필 카드 배치
- 구체 중앙에 수직으로 배치
- `rotation.y = -sphere.rotation.y`로 항상 정면 유지
- Canvas API로 풍부한 디자인 구현

### 3.3 전환 애니메이션
- 구체 확대 → 투명화 → 2D 카드 등장
- `cubic-bezier` 이징으로 자연스러운 움직임
- `rotateY` 효과로 3D → 2D 전환 느낌

### 3.4 상태 관리
- `isAnimating` 플래그로 중복 클릭 방지
- `selectedSphere` 참조로 복원 애니메이션 구현
- 타임라인 객체로 부드러운 보간

## 4. 유틸리티 함수

```javascript
// 텍스트 줄바꿈 함수
function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    
    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = context.measureText(testLine);
        const testWidth = metrics.width;
        
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    context.fillText(line, x, y);
}
```

이 가이드를 따라 구현하면 투명한 구체 내부에 떠 있는 프로필 카드와 클릭 시 2D 변환 효과를 동일하게 재현할 수 있습니다.
