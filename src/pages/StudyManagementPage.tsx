import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import studyService, { Study, ApplicationResponse, MemberResponse, ApplicationStatus } from '../api/studyService';
import studyDetailPageService, { 
  StudyDetailPageData, 
  PageSection, 
  SectionType,
  AddSectionRequest 
} from '../api/studyDetailPageService';
import { SectionRenderer } from '../components/studyDetailPage/sections';
import SectionEditForm from '../components/studyDetailPage/editor/SectionEditForm';
import { normalizeMembersPropsForUI, serializeMembersPropsForAPI } from '../components/studyDetailPage/utils/membersAdapter';
import LoadingSpinner from '../components/common/LoadingSpinner';
import ConfirmModal from '../components/common/ConfirmModal';
import InputModal from '../components/common/InputModal';
import { ToastContainer, ToastType } from '../components/common/Toast';
import styles from './StudyManagementPage.module.css';
import '../components/studyDetailPage/StudyDetailPageRenderer.module.css';

interface TabType {
  key: 'applications' | 'members' | 'page-editor';
  label: string;
  icon: string;
}

const tabs: TabType[] = [
  { key: 'applications', label: 'Ï∞∏Í∞Ä Ïã†Ï≤≠', icon: 'üìã' },
  { key: 'members', label: 'Î©§Î≤Ñ Í¥ÄÎ¶¨', icon: 'üë•' },
  { key: 'page-editor', label: 'ÏÉÅÏÑ∏ ÌéòÏù¥ÏßÄ Ìé∏Ïßë', icon: '‚úèÔ∏è' }
];

const StudyManagementPage: React.FC = () => {
  const navigate = useNavigate();
  const { studyId } = useParams<{ studyId: string }>();
  const { user, isAuthenticated, isLoading: authLoading } = useAuth();
  const [activeTab, setActiveTab] = useState<'applications' | 'members' | 'page-editor'>('applications');
  const [study, setStudy] = useState<Study | null>(null);
  const [applications, setApplications] = useState<ApplicationResponse[]>([]);
  const [members, setMembers] = useState<MemberResponse[]>([]);
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState<string | null>(null);
  
  // Page editor states
  const [pageData, setPageData] = useState<StudyDetailPageData | null>(null);
  const [selectedSection, setSelectedSection] = useState<PageSection | null>(null);
  const [showAddSection, setShowAddSection] = useState(false);
  const [previewMode, setPreviewMode] = useState(false);
  const [saving, setSaving] = useState(false);
  const [draggedSectionId, setDraggedSectionId] = useState<string | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);
  
  // Modal and Toast states
  const [confirmModal, setConfirmModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    onConfirm: () => void;
    confirmButtonClass?: string;
  }>({ 
    isOpen: false, 
    title: '', 
    message: '', 
    onConfirm: () => {},
    confirmButtonClass: 'confirm-button'
  });
  const [inputModal, setInputModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    placeholder?: string;
    onSubmit: (value: string) => void;
  }>({ 
    isOpen: false, 
    title: '', 
    message: '', 
    placeholder: '',
    onSubmit: () => {}
  });
  const [toasts, setToasts] = useState<Array<{
    id: string;
    message: string;
    type?: ToastType;
  }>>([]);

  useEffect(() => {
    const fetchData = async () => {
      if (!studyId) {
        navigate('/study');
        return;
      }

      // Skip authentication check during initial loading
      if (authLoading) {
        return;
      }

      // After loading is complete, check for user existence
      if (!user) {
        navigate('/login', { state: { from: `/study/${studyId}/manage` } });
        return;
      }

      try {
        setLoading(true);
        
        // Fetch study details - studyIdÍ∞Ä Ïã§Ï†úÎ°úÎäî slugÏùº ÏàòÎèÑ ÏûàÏùå
        let studyData = null;
        
        // UUID Ìå®ÌÑ¥ Ï≤¥ÌÅ¨ (Ïà´ÏûêÎÇò slugÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞)
        const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(studyId);
        
        if (isUUID) {
          studyData = await studyService.getStudyById(studyId);
        } else {
          // slugÎ°ú Î®ºÏ†Ä ÏãúÎèÑ
          studyData = await studyService.getStudyBySlug(studyId);
        }
        
        if (!studyData) {
          addToast('Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïä§ÌÑ∞ÎîîÏûÖÎãàÎã§.', 'error');
          navigate('/study');
          return;
        }

        setStudy(studyData);

        // Í∂åÌïú Ï≤¥ÌÅ¨
        // TODO: Î∞±ÏóîÎìúÏóêÏÑú Ïã§Ï†úÎ°ú Ïä§ÌÑ∞Îîî Ìò∏Ïä§Ìä∏Ïù∏ÏßÄ ÌôïÏù∏ÌïòÎäî APIÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.
        // ÌòÑÏû¨Îäî ÌîÑÎ°†Ìä∏ÏóîÎìúÏóêÏÑúÎßå Ï≤¥ÌÅ¨ÌïòÎØÄÎ°ú Î≥¥ÏïàÏÉÅ ÏôÑÎ≤ΩÌïòÏßÄ ÏïäÏäµÎãàÎã§.
        // Î∞±ÏóîÎìúÏóêÏÑú proposerIdÎÇò role Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï¥Ïïº Ìï©ÎãàÎã§.
        
        // Fetch applications - Ïã§Ï†ú study ID ÏÇ¨Ïö©
        try {
          const applicationsData = await studyService.getStudyApplications(studyData.id, 0, 50);
          setApplications(applicationsData.content);
        } catch (error) {
          console.warn('Failed to fetch applications:', error);
          setApplications([]);
        }

        // Fetch members - Ïã§Ï†ú study ID ÏÇ¨Ïö©
        try {
          const membersData = await studyService.getStudyMembers(studyData.id, 0, 50);
          setMembers(membersData.content);
        } catch (error) {
          console.warn('Failed to fetch members:', error);
          setMembers([]);
        }

        // Fetch page data for editor - Ìé∏Ïßë Í∞ÄÎä•Ìïú ÌéòÏù¥ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
        // Í¥ÄÎ¶¨ ÌéòÏù¥ÏßÄÏóêÏÑúÎäî DRAFTÎì† PUBLISHEDÎì† Ìé∏Ïßë Í∞ÄÎä•Ìïú ÌéòÏù¥ÏßÄÎ•º Í∞ÄÏ†∏ÏôÄÏïº Ìï®
        let pageLoaded = false;
        
        // 1. Î®ºÏ†Ä slugÎ°ú published ÌéòÏù¥ÏßÄ ÌôïÏù∏ (ÎåÄÎ∂ÄÎ∂ÑÏùò Í≤ΩÏö∞ published ÏÉÅÌÉú)
        if (studyData.slug) {
          try {
            const pageData = await studyDetailPageService.getPublishedPageBySlug(studyData.slug);
            setPageData(pageData);
            pageLoaded = true;
            console.log('Loaded published page for editing');
          } catch (error: any) {
            if (error.response?.status !== 404) {
              console.error('Error fetching published page:', error);
            }
          }
        }
        
        // 2. PublishedÍ∞Ä ÏóÜÏúºÎ©¥ draft ÌéòÏù¥ÏßÄ ÌôïÏù∏
        if (!pageLoaded) {
          try {
            const pageData = await studyDetailPageService.getDraftPage(studyData.id);
            setPageData(pageData);
            console.log('Loaded draft page for editing');
          } catch (error: any) {
            if (error.response?.status === 404) {
              console.log('No page exists yet for this study');
              setPageData(null); // ÌéòÏù¥ÏßÄÍ∞Ä ÏïÑÏßÅ ÏóÜÏùå - Ï†ïÏÉÅ ÏÉÅÌÉú
            } else {
              console.error('Failed to fetch draft page:', error);
              setPageData(null);
            }
          }
        }

      } catch (error) {
        console.error('Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®:', error);
        addToast('Ïä§ÌÑ∞Îîî Í¥ÄÎ¶¨ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.', 'error');
        navigate('/study');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [studyId, navigate, authLoading, user]);

  const handleAcceptApplication = async (applicationId: string) => {
    if (!study || !user) return;

    const application = applications.find(app => app.id === applicationId);
    if (!application) return;

    setConfirmModal({
      isOpen: true,
      title: 'Ï∞∏Í∞Ä Ïã†Ï≤≠ ÏäπÏù∏',
      message: `${application.applicantId}ÎãòÏùò Ï∞∏Í∞Ä Ïã†Ï≤≠ÏùÑ ÏäπÏù∏ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`,
      onConfirm: async () => {
        setConfirmModal(prev => ({ ...prev, isOpen: false }));
        await doAcceptApplication(applicationId);
      },
      confirmButtonClass: styles.confirmButton
    });
  };
  
  const doAcceptApplication = async (applicationId: string) => {
    if (!study || !user) return;
    
    const application = applications.find(app => app.id === applicationId);
    if (!application) return;

    setActionLoading(applicationId);
    
    try {
      await studyService.acceptApplication(study.id, applicationId, {
        reviewerId: user.email,
        note: 'Ï∞∏Í∞Ä ÏäπÏù∏'
      });

      // Update applications state
      setApplications(prev => 
        prev.map(app => 
          app.id === applicationId 
            ? { ...app, status: ApplicationStatus.ACCEPTED, reviewedBy: user.email, reviewNote: 'Ï∞∏Í∞Ä ÏäπÏù∏' }
            : app
        )
      );

      addToast('Ï∞∏Í∞Ä Ïã†Ï≤≠Ïù¥ ÏäπÏù∏ÎêòÏóàÏäµÎãàÎã§.', 'success');
      
      // Refresh members list
      try {
        const membersData = await studyService.getStudyMembers(study.id, 0, 50);
        setMembers(membersData.content);
      } catch (error) {
        console.warn('Failed to refresh members:', error);
      }
    } catch (error: any) {
      console.error('ÏäπÏù∏ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
      const errorMessage = error.response?.data?.message || 'ÏäπÏù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
      addToast(errorMessage, 'error');
    } finally {
      setActionLoading(null);
    }
  };

  // Page editor handlers
  const handleAddSection = async (type: SectionType | string, props: any) => {
    if (!study || !pageData) return;

    try {
      setSaving(true);
      // ÏÉà ÏÑπÏÖòÏùò order Í∞í Í≥ÑÏÇ∞ - Í∏∞Ï°¥ ÏµúÎåÄÍ∞í + 100
      const maxOrder = pageData.sections.length > 0 
        ? Math.max(...pageData.sections.map(s => s.order || 0))
        : 0;
      
      const request: AddSectionRequest = { 
        type: type as SectionType, 
        props: {
          ...props,
          order: maxOrder + 100  // Î™ÖÏãúÏ†ÅÏúºÎ°ú order Í∞í ÏÑ§Ï†ï
        }
      };
      const updatedPage = await studyDetailPageService.addSection(study!.id, request);
      setPageData(updatedPage);
      setShowAddSection(false);
    } catch (err) {
      console.error('Failed to add section:', err);
      addToast('ÏÑπÏÖò Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  const handleUpdateSection = async (sectionId: string, sectionType: SectionType | string, props: any) => {
    if (!studyId) return;

    try {
      setSaving(true);
      const request: AddSectionRequest = { 
        type: sectionType as SectionType, 
        props: props 
      };
      const updatedPage = await studyDetailPageService.updateSection(study!.id, sectionId, request);
      setPageData(updatedPage);
      setSelectedSection(null);
    } catch (err) {
      console.error('Failed to update section:', err);
      addToast('ÏÑπÏÖò ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  const handleDeleteSection = async (sectionId: string) => {
    if (!studyId) return;
    
    setConfirmModal({
      isOpen: true,
      title: 'ÏÑπÏÖò ÏÇ≠Ï†ú',
      message: 'Ï†ïÎßêÎ°ú Ïù¥ ÏÑπÏÖòÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
      onConfirm: async () => {
        setConfirmModal(prev => ({ ...prev, isOpen: false }));
        await doDeleteSection(sectionId);
      },
      confirmButtonClass: styles.deleteConfirmButton
    });
  };
  
  const doDeleteSection = async (sectionId: string) => {
    if (!studyId) return;

    try {
      setSaving(true);
      const updatedPage = await studyDetailPageService.removeSection(study!.id, sectionId);
      setPageData(updatedPage);
    } catch (err) {
      console.error('Failed to delete section:', err);
      addToast('ÏÑπÏÖò ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  const handleReorderSection = async (sectionId: string, newIndex: number) => {
    if (!studyId || !pageData) return;

    try {
      setSaving(true);
      // ÏÑπÏÖòÏùÑ order Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨Ìïú ÌõÑ Ïû¨Ï†ïÎ†¨
      const sortedSections = [...pageData.sections].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      const currentIndex = sortedSections.findIndex(s => s.id === sectionId);
      if (currentIndex === -1) return;
      
      const [removed] = sortedSections.splice(currentIndex, 1);
      sortedSections.splice(newIndex, 0, removed);
      
      // order Í∞í Ïû¨Í≥ÑÏÇ∞ - 100Ïî© Í∞ÑÍ≤©ÏùÑ ÎëêÏñ¥ Ï∂îÌõÑ Ï§ëÍ∞Ñ ÏÇΩÏûÖ Í∞ÄÎä•
      const reorderedSections = sortedSections.map((section, index) => ({
        ...section,
        order: (index + 1) * 100
      }));
      
      const sectionIds = reorderedSections.map(s => s.id);
      const updatedPage = await studyDetailPageService.reorderSections(study!.id, sectionIds);
      
      // Î°úÏª¨ ÏÉÅÌÉúÎèÑ order Í∞í ÏóÖÎç∞Ïù¥Ìä∏
      if (updatedPage) {
        setPageData({
          ...updatedPage,
          sections: updatedPage.sections.map(s => {
            const reordered = reorderedSections.find(rs => rs.id === s.id);
            return reordered ? { ...s, order: reordered.order } : s;
          })
        });
      }
    } catch (err) {
      console.error('Failed to reorder section:', err);
      addToast('ÏÑπÏÖò ÏàúÏÑú Î≥ÄÍ≤ΩÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  // ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Ìï∏Îì§Îü¨
  const handleDragStart = (e: React.DragEvent, sectionId: string) => {
    setDraggedSectionId(sectionId);
    e.dataTransfer.effectAllowed = 'move';
    // ÎìúÎûòÍ∑∏ Ï§ëÏù∏ ÏöîÏÜå Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '0.5';
    }
  };

  // ÌÇ§Î≥¥Îìú Ï†ëÍ∑ºÏÑ±ÏùÑ ÏúÑÌïú Ìï∏Îì§Îü¨
  const handleKeyDown = (e: React.KeyboardEvent, section: PageSection, index: number) => {
    if (!pageData) return;

    // Alt + ÌôîÏÇ¥Ìëú ÌÇ§Î°ú ÏàúÏÑú Î≥ÄÍ≤Ω
    if (e.altKey) {
      if (e.key === 'ArrowUp' && index > 0) {
        e.preventDefault();
        handleReorderSection(section.id, index - 1);
      } else if (e.key === 'ArrowDown' && index < pageData.sections.length - 1) {
        e.preventDefault();
        handleReorderSection(section.id, index + 1);
      }
    }
    // Enter ÌÇ§Î°ú Ìé∏Ïßë
    else if (e.key === 'Enter') {
      e.preventDefault();
      setSelectedSection(section);
    }
    // Delete ÌÇ§Î°ú ÏÇ≠Ï†ú
    else if (e.key === 'Delete') {
      e.preventDefault();
      handleDeleteSection(section.id);
    }
  };

  const handleDragEnd = (e: React.DragEvent) => {
    // ÎìúÎûòÍ∑∏ Ï¢ÖÎ£å Ïãú Ïä§ÌÉÄÏùº Î≥µÏõê
    if (e.currentTarget instanceof HTMLElement) {
      e.currentTarget.style.opacity = '1';
    }
    setDraggedSectionId(null);
    setDragOverIndex(null);
  };

  const handleDragOver = (e: React.DragEvent, index: number) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    setDragOverIndex(index);
  };

  const handleDragLeave = () => {
    setDragOverIndex(null);
  };

  const handleDrop = async (e: React.DragEvent, dropIndex: number) => {
    e.preventDefault();
    setDragOverIndex(null);
    
    if (!draggedSectionId || !pageData) return;
    
    // Ï†ïÎ†¨Îêú ÏÑπÏÖò Î∞∞Ïó¥ÏóêÏÑú Ïù∏Îç±Ïä§ Ï∞æÍ∏∞
    const sortedSections = [...pageData.sections].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    const draggedIndex = sortedSections.findIndex(s => s.id === draggedSectionId);
    if (draggedIndex === -1 || draggedIndex === dropIndex) return;
    
    await handleReorderSection(draggedSectionId, dropIndex);
  };

  const handleSaveDraft = async () => {
    if (!studyId || !pageData) return;

    try {
      setSaving(true);
      const updatedPage = await studyDetailPageService.saveDraft(study!.id, {
        sections: pageData.sections
      });
      setPageData(updatedPage);
      addToast('Ï¥àÏïàÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§', 'success');
    } catch (err) {
      console.error('Failed to save draft:', err);
      addToast('Ï¥àÏïà Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  const handlePublishPage = async () => {
    if (!studyId) return;
    
    setConfirmModal({
      isOpen: true,
      title: 'ÌéòÏù¥ÏßÄ Î∞úÌñâ',
      message: 'ÌéòÏù¥ÏßÄÎ•º Î∞úÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
      onConfirm: async () => {
        setConfirmModal(prev => ({ ...prev, isOpen: false }));
        await doPublishPage();
      },
      confirmButtonClass: styles.confirmButton
    });
  };
  
  const doPublishPage = async () => {
    if (!studyId) return;

    try {
      setSaving(true);
      const updatedPage = await studyDetailPageService.publish(study!.id);
      setPageData(updatedPage);
      
      // Î∞úÌñâ ÌõÑ ÏÑ†ÌÉùÎêú ÏÑπÏÖòÏùÑ Ìï¥Ï†úÌïòÏó¨ ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î°ú Îã§Ïãú Î°úÎìúÌïòÎèÑÎ°ù Ïú†ÎèÑ
      setSelectedSection(null);
      
      addToast('ÌéòÏù¥ÏßÄÍ∞Ä Î∞úÌñâÎêòÏóàÏäµÎãàÎã§', 'success');
    } catch (err) {
      console.error('Failed to publish page:', err);
      addToast('ÌéòÏù¥ÏßÄ Î∞úÌñâÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
    } finally {
      setSaving(false);
    }
  };

  // Toast helper function
  const addToast = (message: string, type?: ToastType) => {
    const id = Date.now().toString();
    setToasts(prev => [...prev, { id, message, type }]);
  };
  
  const removeToast = (id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  };
  
  const handleRejectApplication = async (applicationId: string) => {
    if (!studyId || !user) return;

    const application = applications.find(app => app.id === applicationId);
    if (!application) return;

    setInputModal({
      isOpen: true,
      title: 'Ï∞∏Í∞Ä Ïã†Ï≤≠ Í±∞Ï†à',
      message: `${application.applicantId}ÎãòÏùò Ï∞∏Í∞Ä Ïã†Ï≤≠ÏùÑ Í±∞Ï†àÌïòÎäî Ïù¥Ïú†Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî:`,
      placeholder: 'Í±∞Ï†à ÏÇ¨Ïú†Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî...',
      onSubmit: async (reason: string) => {
        setInputModal(prev => ({ ...prev, isOpen: false }));
        if (!reason) return;
        
        setActionLoading(applicationId);
        
        try {
          await studyService.rejectApplication(studyId, applicationId, {
            reviewerId: user.email,
            reason: reason.trim()
          });

          // Update applications state
          setApplications(prev => 
            prev.map(app => 
              app.id === applicationId 
                ? { ...app, status: ApplicationStatus.REJECTED, reviewedBy: user.email, reviewNote: reason.trim() }
                : app
            )
          );

          addToast('Ï∞∏Í∞Ä Ïã†Ï≤≠Ïù¥ Í±∞Ï†àÎêòÏóàÏäµÎãàÎã§.', 'info');
        } catch (error: any) {
          console.error('Í±∞Ï†à Ï≤òÎ¶¨ Ïã§Ìå®:', error);
          const errorMessage = error.response?.data?.message || 'Í±∞Ï†à Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
          addToast(errorMessage, 'error');
        } finally {
          setActionLoading(null);
        }
      }
    });
  };

  const getStatusBadge = (status: ApplicationStatus) => {
    switch (status) {
      case ApplicationStatus.PENDING:
        return <span className={`${styles.statusBadge} ${styles.pending}`}>ÎåÄÍ∏∞Ï§ë</span>;
      case ApplicationStatus.ACCEPTED:
        return <span className={`${styles.statusBadge} ${styles.accepted}`}>ÏäπÏù∏Îê®</span>;
      case ApplicationStatus.REJECTED:
        return <span className={`${styles.statusBadge} ${styles.rejected}`}>Í±∞Ï†àÎê®</span>;
      default:
        return <span className={styles.statusBadge}>{status}</span>;
    }
  };

  const formatDate = (dateString: string) => {
    try {
      return new Date(dateString).toLocaleDateString('ko-KR', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch {
      return dateString;
    }
  };

  if (loading) {
    return (
      <div className={styles.studyManagementPage}>
        <div className={styles.loadingState}>
          <LoadingSpinner message="Ïä§ÌÑ∞Îîî Í¥ÄÎ¶¨ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë..." fullScreen={false} />
        </div>
      </div>
    );
  }

  if (!study) {
    return null;
  }

  const pendingApplications = applications.filter(app => app.status === ApplicationStatus.PENDING);
  const processedApplications = applications.filter(app => app.status !== ApplicationStatus.PENDING);

  return (
    <div className={styles.studyManagementPage}>
      <div className={styles.managementContainer}>
        <div className={styles.managementHeader}>
          <button 
            onClick={() => navigate(`/study/${study.slug}`)} 
            className={styles.backButton}
          >
            ‚Üê Ïä§ÌÑ∞ÎîîÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞
          </button>
          <h1>Ïä§ÌÑ∞Îîî Í¥ÄÎ¶¨</h1>
          <div className={styles.studyInfo}>
            <h2>{study.name} {study.generation > 1 && `${study.generation}Í∏∞`}</h2>
            <p className={styles.studyTagline}>{study.tagline}</p>
            <div className={styles.studyStats}>
              <span>üìã Ïã†Ï≤≠Ïûê {applications.length}Î™Ö</span>
              <span>üë• Î©§Î≤Ñ {members.length}Î™Ö</span>
              <span>‚è≥ ÎåÄÍ∏∞ {pendingApplications.length}Î™Ö</span>
              {pageData && (
                <span>
                  {pageData.status === 'PUBLISHED' ? '‚úÖ Î∞úÌñâÎê®' : 'üìù Ï¥àÏïà'}
                  {pageData.publishedAt && pageData.status === 'PUBLISHED' && ` (${(() => {
                    try {
                      if (Array.isArray(pageData.publishedAt)) {
                        const [year, month, day] = pageData.publishedAt;
                        const date = new Date(year, month - 1, day);
                        return date.toLocaleDateString('ko-KR');
                      }
                      const date = new Date(pageData.publishedAt);
                      return isNaN(date.getTime()) ? 'ÎÇ†Ïßú ÏóÜÏùå' : date.toLocaleDateString('ko-KR');
                    } catch {
                      return 'ÎÇ†Ïßú ÏóÜÏùå';
                    }
                  })()})`}
                </span>
              )}
            </div>
          </div>
          {/* Í∂åÌïú ÏïàÎÇ¥ Î©îÏãúÏßÄ */}
          {applications.length === 0 && members.length === 0 && (
            <div style={{
              background: 'rgba(255, 193, 7, 0.1)',
              border: '1px solid rgba(255, 193, 7, 0.3)',
              borderRadius: '8px',
              padding: '12px 16px',
              marginTop: '16px',
              color: '#ffc107',
              fontSize: '14px'
            }}>
              ‚ö†Ô∏è Ïä§ÌÑ∞Îîî Ìò∏Ïä§Ìä∏Îßå Ïù¥ ÌéòÏù¥ÏßÄÏóê Ï†ëÍ∑ºÌï† Ïàò ÏûàÏäµÎãàÎã§. Í∂åÌïúÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Îç∞Ïù¥ÌÑ∞Í∞Ä ÌëúÏãúÎêòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.
            </div>
          )}
        </div>

        <div className={styles.tabNavigation}>
          {tabs.map(tab => (
            <button
              key={tab.key}
              className={`${styles.tabButton} ${activeTab === tab.key ? styles.active : ''}`}
              onClick={() => setActiveTab(tab.key)}
            >
              <span className={styles.tabIcon}>{tab.icon}</span>
              {tab.label}
              {tab.key === 'applications' && pendingApplications.length > 0 && (
                <span className={styles.badge}>{pendingApplications.length}</span>
              )}
            </button>
          ))}
        </div>

        {activeTab === 'applications' && (
          <div className={styles.applicationsSection}>
            {pendingApplications.length > 0 && (
              <div className={styles.pendingApplications}>
                <h3>üîî Í≤ÄÌÜ† ÎåÄÍ∏∞ Ï§ëÏù∏ Ïã†Ï≤≠</h3>
                <div className={styles.applicationsGrid}>
                  {pendingApplications.map(application => (
                    <div key={application.id} className={`${styles.applicationCard} ${styles.pending}`}>
                      <div className={styles.applicationHeader}>
                        <h4>{application.applicantId}</h4>
                        {getStatusBadge(application.status)}
                        <span className={styles.applicationDate}>
                          {formatDate(application.createdAt)}
                        </span>
                      </div>

                      <div className={styles.applicationContent}>
                        {Object.entries(application.answers).map(([question, answer]) => (
                          <div key={question} className={styles.answerItem}>
                            <strong className={styles.questionLabel}>
                              {question === 'motivation' && 'Ï∞∏Ïó¨ ÎèôÍ∏∞:'}
                              {question === 'experience' && 'Í¥ÄÎ†® Í≤ΩÌóò:'}
                              {question === 'availability' && 'Ï∞∏Ïó¨ Í∞ÄÎä• ÏãúÍ∞Ñ:'}
                              {question === 'expectations' && 'Í∏∞ÎåÄÌïòÎäî Ï†ê:'}
                              {question === 'commitment' && 'Í∞ÅÏò§ ÌïúÎßàÎîî:'}
                              {!['motivation', 'experience', 'availability', 'expectations', 'commitment'].includes(question) && `${question}:`}
                            </strong>
                            <p className={styles.answerText}>{answer}</p>
                          </div>
                        ))}
                      </div>

                      <div className={styles.applicationActions}>
                        <button 
                          onClick={() => handleRejectApplication(application.id)}
                          className={styles.rejectButton}
                          disabled={actionLoading === application.id}
                        >
                          {actionLoading === application.id ? 'Ï≤òÎ¶¨ Ï§ë...' : 'Í±∞Ï†à'}
                        </button>
                        <button 
                          onClick={() => handleAcceptApplication(application.id)}
                          className={styles.acceptButton}
                          disabled={actionLoading === application.id}
                        >
                          {actionLoading === application.id ? 'Ï≤òÎ¶¨ Ï§ë...' : 'ÏäπÏù∏'}
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {processedApplications.length > 0 && (
              <div className={styles.processedApplications}>
                <h3>üìÑ Ï≤òÎ¶¨ ÏôÑÎ£åÎêú Ïã†Ï≤≠</h3>
                <div className={styles.applicationsList}>
                  {processedApplications.map(application => (
                    <div key={application.id} className={styles.applicationItem}>
                      <div className={styles.applicationSummary}>
                        <span className={styles.applicantName}>{application.applicantId}</span>
                        {getStatusBadge(application.status)}
                        <span className={styles.applicationDate}>{formatDate(application.createdAt)}</span>
                      </div>
                      {application.reviewNote && (
                        <div className={styles.reviewNote}>
                          <strong>Í≤ÄÌÜ† Î©îÎ™®:</strong> {application.reviewNote}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {applications.length === 0 && (
              <div className={styles.emptyState}>
                <div className={styles.emptyIcon}>üì≠</div>
                <h3>ÏïÑÏßÅ Ï∞∏Í∞Ä Ïã†Ï≤≠Ïù¥ ÏóÜÏäµÎãàÎã§</h3>
                <p>Ïä§ÌÑ∞ÎîîÍ∞Ä Í≥µÍ∞úÎêòÎ©¥ Ï∞∏Í∞Ä Ïã†Ï≤≠Ïù¥ Îì§Ïñ¥Ïò¨ ÏòàÏ†ïÏûÖÎãàÎã§.</p>
              </div>
            )}
          </div>
        )}

        {activeTab === 'members' && (
          <div className={styles.membersSection}>
            {members.length > 0 ? (
              <div className={styles.membersGrid}>
                {members.map(member => (
                  <div key={member.id} className={styles.memberCard}>
                    <div className={styles.memberInfo}>
                      <h4>{member.userId}</h4>
                      <span className={styles.memberRole}>{member.role}</span>
                    </div>
                    <div className={styles.memberMeta}>
                      <span>Í∞ÄÏûÖ: {formatDate(member.joinedAt)}</span>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className={styles.emptyState}>
                <div className={styles.emptyIcon}>üë•</div>
                <h3>ÏïÑÏßÅ Î©§Î≤ÑÍ∞Ä ÏóÜÏäµÎãàÎã§</h3>
                <p>Ï∞∏Í∞Ä Ïã†Ï≤≠ÏùÑ ÏäπÏù∏ÌïòÎ©¥ Î©§Î≤ÑÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§.</p>
              </div>
            )}
          </div>
        )}

        {activeTab === 'page-editor' && (
          <div className={styles.pageEditorSection}>
            <div className={styles.editorHeader}>
              <div className={styles.editorActions}>
                <button 
                  className={styles.btnPreview}
                  onClick={() => setPreviewMode(!previewMode)}
                >
                  {previewMode ? 'Ìé∏Ïßë Î™®Îìú' : 'ÎØ∏Î¶¨Î≥¥Í∏∞'}
                </button>
                {/* Ï¥àÏïà Ï†ÄÏû• Î≤ÑÌäº Ï†úÍ±∞: Ïä§ÎÉÖÏÉ∑ ÎØ∏ÎèÑÏûÖ ÏÉÅÌÉúÏóêÏÑú ÌòºÎûÄ Î∞©ÏßÄ */}
                <button 
                  className={styles.btnPublish}
                  onClick={handlePublishPage}
                  disabled={saving}
                >
                  Î∞úÌñâÌïòÍ∏∞
                </button>
                {study?.slug && (
                  <button 
                    className={styles.btnView}
                    onClick={() => window.open(`/study/${study.slug}`, '_blank')}
                  >
                    ÌéòÏù¥ÏßÄ Î≥¥Í∏∞ ‚Üí
                  </button>
                )}
              </div>
            </div>

            {!pageData ? (
              <div className={styles.noPageMessage}>
                <div style={{ fontSize: '48px', marginBottom: '20px', opacity: 0.5 }}>üìÑ</div>
                <h3 style={{ fontSize: '1.2rem', marginBottom: '10px', color: '#C3E88D' }}>
                  ÏÉÅÏÑ∏ ÌéòÏù¥ÏßÄÎ•º ÎßåÎì§Ïñ¥Î≥¥ÏÑ∏Ïöî
                </h3>
                <p style={{ marginBottom: '20px', color: 'rgba(255, 255, 255, 0.7)' }}>
                  Ïä§ÌÑ∞Îîî ÏÜåÍ∞ú ÌéòÏù¥ÏßÄÎ•º ÏÉùÏÑ±ÌïòÍ≥† Îã§ÏñëÌïú ÏÑπÏÖòÏùÑ Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§.
                </p>
                <button 
                  onClick={async () => {
                    if (!studyId) return;
                    try {
                      setSaving(true);
                      // Î∞±ÏóîÎìúÍ∞Ä study.slugÎ•º ÏÇ¨Ïö©Ìï¥ ÏÉùÏÑ±ÌïúÎã§Îäî Ï†ÑÏ†ú
                      const newPage = await studyDetailPageService.createPage(study!.id, { slug: study!.slug });
                      setPageData(newPage);
                      addToast('ÌéòÏù¥ÏßÄÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§! ÏÑπÏÖòÏùÑ Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî.', 'success');
                    } catch (err) {
                      console.error('Failed to create page:', err);
                      addToast('ÌéòÏù¥ÏßÄ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
                    } finally {
                      setSaving(false);
                    }
                  }}
                  disabled={saving}
                  style={{
                    background: 'linear-gradient(135deg, #C3E88D 0%, #89DDFF 100%)',
                    color: '#1a1a1a',
                    border: 'none',
                    borderRadius: '8px',
                    padding: '12px 24px',
                    fontSize: '15px',
                    fontWeight: '600',
                    cursor: saving ? 'not-allowed' : 'pointer',
                    opacity: saving ? 0.6 : 1,
                    transition: 'all 0.3s ease'
                  }}
                  onMouseEnter={(e) => {
                    if (!saving) {
                      e.currentTarget.style.transform = 'translateY(-2px)';
                      e.currentTarget.style.boxShadow = '0 6px 20px rgba(195, 232, 141, 0.4)';
                    }
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = 'translateY(0)';
                    e.currentTarget.style.boxShadow = 'none';
                  }}
                >
                  {saving ? 'ÏÉùÏÑ± Ï§ë...' : 'üöÄ ÌéòÏù¥ÏßÄ ÏÉùÏÑ±ÌïòÍ∏∞'}
                </button>
              </div>
            ) : previewMode ? (
              <div className={styles.previewContainer}>
                <h4>ÎØ∏Î¶¨Î≥¥Í∏∞</h4>
                <div className={`${styles.previewContent} study-detail-page-content`}>
                  <div className={styles.sectionsContainer}>
                    {pageData.sections.length === 0 ? (
                      <p style={{ textAlign: 'center', padding: '40px', color: '#999' }}>ÏïÑÏßÅ ÏÑπÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.</p>
                    ) : (
                      // ÌçºÎ∏îÎ¶≠ Î†åÎçîÎü¨ÏôÄ ÎèôÏùºÌïú Ï†ïÎ†¨ Ï†ÅÏö© - order Í∞í Í∏∞Ï§Ä
                      [...pageData.sections].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)).map((section) => (
                        <div key={section.id} className={styles.sectionWrapper}>
                          <SectionRenderer type={section.type} data={section.props} />
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>
            ) : (
              <div className={styles.editorContent} style={{ display: 'flex', gap: '24px' }}>
                <div className={styles.sectionsManager} style={{ flex: '0 0 380px', minWidth: '380px' }}>
                  <div className={styles.sectionsHeader}>
                    <h4>ÏÑπÏÖò Í¥ÄÎ¶¨</h4>
                    <button 
                      className={styles.btnAddSection}
                      onClick={() => setShowAddSection(true)}
                    >
                      + ÏÑπÏÖò Ï∂îÍ∞Ä
                    </button>
                  </div>
                  
                  <div className={styles.keyboardShortcutsHint}>
                    <span className={styles.shortcutIcon}>‚å®Ô∏è</span>
                    <span className={styles.shortcutText}>
                      <span className={styles.key}>Alt + ‚Üë‚Üì</span> Ïù¥Îèô ¬∑ 
                      <span className={styles.key}>Enter</span> Ìé∏Ïßë ¬∑ 
                      <span className={styles.key}>Delete</span> ÏÇ≠Ï†ú
                    </span>
                  </div>

                  {showAddSection && (
                    <div className={styles.addSectionModal}>
                      <div className={styles.modalContent}>
                        <h5>ÏÉà ÏÑπÏÖò Ï∂îÍ∞Ä</h5>
                        <div className={styles.sectionTypes}>
                          {[
                            SectionType.HERO,
                            SectionType.RICH_TEXT,
                            SectionType.MEMBERS,
                            SectionType.FAQ,
                            SectionType.REVIEWS,
                            SectionType.HOW_WE_ROLL,
                            SectionType.JOURNEY,
                            SectionType.EXPERIENCE
                          ].map((type) => (
                            <button
                              key={type}
                              className={styles.sectionTypeBtn}
                              onClick={() => {
                                // ÏûÑÏãú ID ÏÉùÏÑ± (Ï†ÄÏû• Ï†ÑÍπåÏßÄ ÏÇ¨Ïö©)
                                const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                                const maxOrder = pageData.sections.length > 0 
                                  ? Math.max(...pageData.sections.map(s => s.order || 0))
                                  : 0;
                                
                                // ÏÉà ÏÑπÏÖòÏùÑ Ï¶âÏãú Î™©Î°ùÏóê Ï∂îÍ∞Ä
                                const newSection = {
                                  id: tempId,
                                  type: type as any,
                                  props: {},
                                  order: maxOrder + 100,
                                  isTemp: true  // ÏûÑÏãú ÏÑπÏÖò ÌëúÏãú
                                };
                                
                                // pageDataÏóê Ï¶âÏãú Ï∂îÍ∞Ä
                                setPageData(prev => prev ? {
                                  ...prev,
                                  sections: [...prev.sections, newSection]
                                } : prev);
                                
                                // Ìé∏Ïßë Î™®ÎìúÎ°ú Ï†ÑÌôò
                                setSelectedSection(newSection);
                                setShowAddSection(false);
                              }}
                            >
                              {type}
                            </button>
                          ))}
                        </div>
                        <button 
                          className={styles.btnCancel}
                          onClick={() => setShowAddSection(false)}
                        >
                          Ï∑®ÏÜå
                        </button>
                      </div>
                    </div>
                  )}

                  <div className={styles.studyMgmtSectionsList}>
                    {pageData.sections.length === 0 ? (
                      <p className={styles.studyMgmtEmptyMessage}>ÏïÑÏßÅ ÏÑπÏÖòÏù¥ ÏóÜÏäµÎãàÎã§. ÏÑπÏÖòÏùÑ Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.</p>
                    ) : (
                      // ÏÑπÏÖò Î™©Î°ùÎèÑ order Í∞í Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                      [...pageData.sections].sort((a, b) => (a.order ?? 0) - (b.order ?? 0)).map((section, index) => (
                        <div 
                          key={section.id} 
                          className={`${styles.studyMgmtSectionItem} ${
                            draggedSectionId === section.id ? styles.studyMgmtSectionDragging : ''
                          } ${
                            dragOverIndex === index ? styles.studyMgmtSectionDragOver : ''
                          } ${
                            section.id.startsWith('temp_') ? styles.tempSection : ''
                          }`}
                          draggable
                          tabIndex={0}
                          role="listitem"
                          aria-label={`${section.type} ÏÑπÏÖò, ${index + 1}Î≤àÏß∏ ÏúÑÏπò. Alt+ÌôîÏÇ¥ÌëúÎ°ú ÏàúÏÑú Î≥ÄÍ≤Ω, EnterÎ°ú Ìé∏Ïßë, DeleteÎ°ú ÏÇ≠Ï†ú`}
                          onDragStart={(e) => handleDragStart(e, section.id)}
                          onDragEnd={handleDragEnd}
                          onDragOver={(e) => handleDragOver(e, index)}
                          onDragLeave={handleDragLeave}
                          onDrop={(e) => handleDrop(e, index)}
                          onKeyDown={(e) => handleKeyDown(e, section, index)}
                        >
                          <div className={styles.studyMgmtDragHandle} title="ÎìúÎûòÍ∑∏ÌïòÏó¨ ÏàúÏÑú Î≥ÄÍ≤Ω">
                            <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                              <circle cx="6" cy="4" r="1.5" fill="currentColor" opacity="0.6"/>
                              <circle cx="6" cy="10" r="1.5" fill="currentColor" opacity="0.6"/>
                              <circle cx="6" cy="16" r="1.5" fill="currentColor" opacity="0.6"/>
                              <circle cx="14" cy="4" r="1.5" fill="currentColor" opacity="0.6"/>
                              <circle cx="14" cy="10" r="1.5" fill="currentColor" opacity="0.6"/>
                              <circle cx="14" cy="16" r="1.5" fill="currentColor" opacity="0.6"/>
                            </svg>
                          </div>
                          <div className={styles.studyMgmtSectionInfo}>
                            <span className={styles.studyMgmtSectionType}>{section.type}</span>
                            {section.id.startsWith('temp_') && (
                              <span className={styles.tempLabel}>Ï†ÄÏû• ÌïÑÏöî</span>
                            )}
                          </div>
                          <div className={styles.studyMgmtSectionActions}>
                            <button 
                              className={styles.studyMgmtEditBtn}
                              onClick={() => setSelectedSection(section)}
                              title="ÏÑπÏÖò Ìé∏Ïßë"
                            >
                              ‚úèÔ∏è
                            </button>
                            <button 
                              className={styles.studyMgmtDeleteBtn}
                              onClick={() => handleDeleteSection(section.id)}
                              title="ÏÑπÏÖò ÏÇ≠Ï†ú"
                            >
                              üóëÔ∏è
                            </button>
                          </div>
                        </div>
                      ))
                    )}
                  </div>
                </div>

                {selectedSection && (
                  <div className={styles.sectionEditor} style={{ flex: 1, minWidth: 0 }}>
                    <button 
                      className={styles.sectionEditorClose}
                      onClick={() => setSelectedSection(null)}
                      aria-label="Ìé∏ÏßëÏ∞Ω Îã´Í∏∞"
                    >
                      ‚úï
                    </button>
                    <SectionEditForm
                      sectionType={selectedSection.type}
                      studyId={study?.id}  // Ïã§Ï†ú Ïä§ÌÑ∞Îîî ID Ï†ÑÎã¨
                      initialData={selectedSection.type === SectionType.MEMBERS
                        ? normalizeMembersPropsForUI(selectedSection.props || {})
                        : (selectedSection.props || {})}
                      onSave={async (data) => {
                        const outgoing = selectedSection.type === SectionType.MEMBERS
                          ? serializeMembersPropsForAPI(data)
                          : data;
                        
                        // ÏûÑÏãú ÏÑπÏÖòÏù∏ Í≤ΩÏö∞ (temp_Î°ú ÏãúÏûëÌïòÎäî ID)
                        if (selectedSection.id.startsWith('temp_')) {
                          // API Ìò∏Ï∂úÎ°ú Ïã§Ï†ú ÏÑπÏÖò ÏÉùÏÑ±
                          try {
                            setSaving(true);
                            const request: AddSectionRequest = { 
                              type: selectedSection.type as SectionType, 
                              props: {
                                ...outgoing,
                                order: selectedSection.order || 0
                              }
                            };
                            const updatedPage = await studyDetailPageService.addSection(study!.id, request);
                            setPageData(updatedPage);
                            setSelectedSection(null);
                            addToast('ÏÑπÏÖòÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§', 'success');
                          } catch (err) {
                            console.error('Failed to add section:', err);
                            addToast('ÏÑπÏÖò Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§', 'error');
                            // Ïã§Ìå®Ïãú ÏûÑÏãú ÏÑπÏÖò Ï†úÍ±∞
                            setPageData(prev => prev ? {
                              ...prev,
                              sections: prev.sections.filter(s => s.id !== selectedSection.id)
                            } : prev);
                          } finally {
                            setSaving(false);
                          }
                        } else {
                          // Í∏∞Ï°¥ ÏÑπÏÖò ÏóÖÎç∞Ïù¥Ìä∏
                          handleUpdateSection(selectedSection.id, selectedSection.type, outgoing);
                        }
                      }}
                      onCancel={() => {
                        // ÏûÑÏãú ÏÑπÏÖòÏù∏ Í≤ΩÏö∞ Î™©Î°ùÏóêÏÑú Ï†úÍ±∞
                        if (selectedSection.id.startsWith('temp_')) {
                          setPageData(prev => prev ? {
                            ...prev,
                            sections: prev.sections.filter(s => s.id !== selectedSection.id)
                          } : prev);
                        }
                        setSelectedSection(null);
                      }}
                    />
                  </div>
                )}
              </div>
            )}

            {saving && (
              <div className={styles.savingOverlay}>
                <LoadingSpinner />
                <p>Ï†ÄÏû• Ï§ë...</p>
              </div>
            )}
          </div>
        )}
      </div>
      
      <ConfirmModal
        isOpen={confirmModal.isOpen}
        title={confirmModal.title}
        message={confirmModal.message}
        confirmButtonClass={confirmModal.confirmButtonClass}
        onConfirm={confirmModal.onConfirm}
        onCancel={() => setConfirmModal(prev => ({ ...prev, isOpen: false }))}
      />
      
      <InputModal
        isOpen={inputModal.isOpen}
        title={inputModal.title}
        message={inputModal.message}
        placeholder={inputModal.placeholder}
        onSubmit={inputModal.onSubmit}
        onCancel={() => setInputModal(prev => ({ ...prev, isOpen: false }))}
        multiline={true}
        maxLength={500}
      />
      
      <ToastContainer toasts={toasts} onClose={removeToast} />
    </div>
  );
};

export default StudyManagementPage;