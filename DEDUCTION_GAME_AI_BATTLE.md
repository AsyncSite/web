# ğŸ† ì¶”ë¡  ê²Œì„ AI ë°°í‹€

## ë¬¸ì œ ì„¤ëª…

**ì¶”ë¡  ê²Œì„ AI ë°°í‹€**ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì´ ë„ì „ì—ì„œëŠ” ì „ëµì  ì¶”ì¸¡ê³¼ ë…¼ë¦¬ì  ì¶”ë¡ ì„ í†µí•´ ìˆ¨ê²¨ì§„ ì •ë‹µ í‚¤ì›Œë“œë¥¼ ì°¾ì•„ë‚´ëŠ” AI ì—ì´ì „íŠ¸ë¥¼ êµ¬í˜„í•˜ê²Œ ë©ë‹ˆë‹¤.

### ê°œìš”

ì¶”ë¡  ê²Œì„ì€ ë” í° í‚¤ì›Œë“œ í’€ì—ì„œ ì •ë‹µ í‚¤ì›Œë“œ ì„¸íŠ¸ë¥¼ ì°¾ì•„ë‚´ì•¼ í•˜ëŠ” ë©€í‹°í”Œë ˆì´ì–´ ë…¼ë¦¬ í¼ì¦ì…ë‹ˆë‹¤. ê° í”Œë ˆì´ì–´ëŠ” ê³ ìœ í•œ íŒíŠ¸(ì •ë‹µì´ ì•„ë‹Œ í‚¤ì›Œë“œë“¤)ë¥¼ ë°›ìœ¼ë©°, ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì¶”ì¸¡ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì—°ì—­ì  ì¶”ë¡ ì„ ì‚¬ìš©í•˜ì—¬ ì •ë‹µì„ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤.

**í•µì‹¬ ë„ì „**: ì¶”ì¸¡ì—ì„œ ëª‡ ê°œì˜ í‚¤ì›Œë“œê°€ ë§ì•˜ëŠ”ì§€ë§Œ ì•Œ ìˆ˜ ìˆê³ , ì–´ë–¤ ê²ƒì´ ë§ì•˜ëŠ”ì§€ëŠ” ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

### ê²Œì„ ê·œì¹™

1. **ì„¤ì • ë‹¨ê³„**
   - í‚¤ì›Œë“œ í’€ì´ ì œê³µë©ë‹ˆë‹¤ (ì˜ˆ: 50ê°œ ë‹¨ì–´)
   - ì¼ë¶€ê°€ ë¹„ë°€ë¦¬ì— ì •ë‹µìœ¼ë¡œ ì„ íƒë©ë‹ˆë‹¤ (ì˜ˆ: 5ê°œ ì •ë‹µ)
   - ê° í”Œë ˆì´ì–´ëŠ” ê³ ìœ í•œ íŒíŠ¸ë¥¼ ë°›ìŠµë‹ˆë‹¤ (ì •ë‹µì´ ì•„ë‹Œ í‚¤ì›Œë“œë“¤)

2. **ê²Œì„ ì§„í–‰**
   - í”Œë ˆì´ì–´ë“¤ì´ ì°¨ë¡€ëŒ€ë¡œ ì¶”ì¸¡ì„ í•©ë‹ˆë‹¤
   - ê° ì¶”ì¸¡ì€ ì •í™•íˆ `answerCount`ê°œì˜ í‚¤ì›Œë“œë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤
   - ê° ì¶”ì¸¡ í›„, ë§ì¶˜ í‚¤ì›Œë“œì˜ ê°œìˆ˜ë§Œ ê³µê°œë©ë‹ˆë‹¤
   - í•œ í”Œë ˆì´ì–´ê°€ ëª¨ë“  ì •ë‹µì„ ë§ì¶”ë©´ ê²Œì„ì´ ì¢…ë£Œë©ë‹ˆë‹¤

3. **ìŠ¹ë¦¬ ì¡°ê±´**
   - ëª¨ë“  ì •ë‹µì„ ë¨¼ì € ë§ì¶˜ í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬í•©ë‹ˆë‹¤
   - ìµœëŒ€ í„´ì— ë„ë‹¬í•˜ë©´, ê°€ì¥ ë§ì€ ì •ë³´ë¥¼ ê°€ì§„ í”Œë ˆì´ì–´ê°€ ìŠ¹ë¦¬í•©ë‹ˆë‹¤
   - í„´ë‹¹ ì‹œê°„ ì œí•œìœ¼ë¡œ ë¹ ë¥¸ ì˜ì‚¬ê²°ì •ì´ í•„ìš”í•©ë‹ˆë‹¤

### ì…ë ¥ í˜•ì‹

ë‹¹ì‹ ì˜ AIëŠ” ë‹¤ìŒì„ í¬í•¨í•˜ëŠ” `gameState` ê°ì²´ë¥¼ ë°›ìŠµë‹ˆë‹¤:

```javascript
{
    keywords: string[],              // ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  í‚¤ì›Œë“œ
    myHints: number[],              // ì •ë‹µì´ ì•„ë‹Œ í‚¤ì›Œë“œì˜ ì¸ë±ìŠ¤
    answerCount: number,            // ì°¾ì•„ì•¼ í•  ì •ë‹µ ê°œìˆ˜
    previousGuesses: GuessHistory[], // ëª¨ë“  ì´ì „ ì¶”ì¸¡ê³¼ ê²°ê³¼
    revealedAnswers: number[],      // í™•ì¸ëœ ì •ë‹µ
    revealedWrongAnswers: number[], // í™•ì¸ëœ ì˜¤ë‹µ
    currentTurn: number,            // í˜„ì¬ í„´ ë²ˆí˜¸
    timeLimit: number               // ì‹œê°„ ì œí•œ (ì´ˆ)
}
```

`GuessHistory`ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:
```javascript
{
    playerId: number,
    guess: number[],      // ì¶”ì¸¡í•œ í‚¤ì›Œë“œ ì¸ë±ìŠ¤
    correctCount: number  // ë§ì¶˜ ê°œìˆ˜
}
```

### ì¶œë ¥ í˜•ì‹

ë‹¹ì‹ ì˜ ì¶”ì¸¡ì„ ë‚˜íƒ€ë‚´ëŠ” í‚¤ì›Œë“œ ì¸ë±ìŠ¤ ë°°ì—´ì„ ë°˜í™˜í•˜ì„¸ìš”:

```javascript
[0, 2, 5, 8, 11]  // ì˜ˆì‹œ: ì´ ì¸ë±ìŠ¤ë“¤ì˜ í‚¤ì›Œë“œë¥¼ ì¶”ì¸¡
```

### ì œì•½ì‚¬í•­

- **ì‹œê°„ ì œí•œ**: í„´ë‹¹ 2ì´ˆ
- **ë©”ëª¨ë¦¬ ì œí•œ**: 128 MB
- **ì½”ë“œ í¬ê¸°**: ìµœëŒ€ 10,000ì
- **ìœ íš¨í•œ ì¶”ì¸¡**: ì •í™•íˆ `answerCount`ê°œì˜ ê³ ìœ í•œ ì¸ë±ìŠ¤ë¥¼ í¬í•¨í•´ì•¼ í•¨
- **ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ ê¸ˆì§€**: ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ë‚˜ íŒŒì¼ I/O ê¸ˆì§€
- **ê²°ì •ë¡ ì **: ê°™ì€ ì…ë ¥ì€ ê°™ì€ ì¶œë ¥ì„ ìƒì„±í•´ì•¼ í•¨

### í‰ê°€ ê¸°ì¤€

ë‹¹ì‹ ì˜ AIëŠ” ë‹¤ìŒ ê¸°ì¤€ìœ¼ë¡œ í‰ê°€ë©ë‹ˆë‹¤:

1. **ìŠ¹ë¥ ** (40%): ìŠ¹ë¦¬í•œ ê²Œì„ì˜ ë¹„ìœ¨
2. **íš¨ìœ¨ì„±** (30%): ìŠ¹ë¦¬ê¹Œì§€ì˜ í‰ê·  í„´ ìˆ˜
3. **ì†ë„** (20%): ì˜ì‚¬ê²°ì •ë‹¹ í‰ê·  ì‹œê°„
4. **ì•ˆì •ì„±** (10%): ë‹¤ì–‘í•œ ì „ëµì— ëŒ€í•œ ì„±ëŠ¥

---

## ì•Œê³ ë¦¬ì¦˜ íŠœí† ë¦¬ì–¼

### 1. ë¬¸ì œ ê³µê°„ ì´í•´í•˜ê¸°

ì¶”ë¡  ê²Œì„ì€ ê·¼ë³¸ì ìœ¼ë¡œ ë¶€ë¶„ ì •ë³´ë¥¼ ê°€ì§„ **ì œì•½ ë§Œì¡± ë¬¸ì œ(CSP)**ì…ë‹ˆë‹¤. ê° ì¶”ì¸¡ì€ ì œì•½ ì¡°ê±´ì„ ì œê³µí•˜ë©°, ëª©í‘œëŠ” ëª¨ë“  ì œì•½ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í‚¤ì›Œë“œ í• ë‹¹ì„ ì°¾ëŠ” ê²ƒì…ë‹ˆë‹¤.

#### ì˜ˆì‹œ ì‹œë‚˜ë¦¬ì˜¤

```
í‚¤ì›Œë“œ: ['ê³ ì–‘ì´', 'ê°œ', 'ìƒˆ', 'ë¬¼ê³ ê¸°', 'ì‚¬ì']
ì •ë‹µ: [0, 2, 4] (ê³ ì–‘ì´, ìƒˆ, ì‚¬ì) - í”Œë ˆì´ì–´ì—ê²Œ ìˆ¨ê²¨ì§
ë‹¹ì‹ ì˜ íŒíŠ¸: [1] (ê°œëŠ” ì •ë‹µì´ ì•„ë‹˜)

í„´ 1: ì¶”ì¸¡ [0, 1, 2] â†’ ê²°ê³¼: 2ê°œ ì •ë‹µ
ë¶„ì„: ê°œ(1)ëŠ” íŒíŠ¸ì´ë¯€ë¡œ, ê³ ì–‘ì´(0)ì™€ ìƒˆ(2)ê°€ 2ê°œì˜ ì •ë‹µì´ì–´ì•¼ í•¨
```

### 2. í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ ì ‘ê·¼ë²•

#### ì ‘ê·¼ë²• 1: ì œì•½ ë§Œì¡± ë¬¸ì œ (CSP)

```javascript
function solveCSP(gameState) {
    const constraints = extractConstraints(gameState.previousGuesses);
    const domains = initializeDomains(gameState);
    
    // ì œì•½ ì „íŒŒë¥¼ í†µí•œ ë°±íŠ¸ë˜í‚¹
    function backtrack(assignment, remaining) {
        if (remaining.length === 0) {
            return assignment;
        }
        
        const variable = selectUnassignedVariable(remaining);
        
        for (const value of orderDomainValues(variable, domains)) {
            if (isConsistent(value, assignment, constraints)) {
                assignment.add(value);
                
                // ì „ë°© ê²€ì‚¬
                const inference = makeInference(value, domains, constraints);
                if (inference !== null) {
                    const result = backtrack(assignment, remaining.filter(v => v !== variable));
                    if (result !== null) return result;
                }
                
                assignment.delete(value);
                undoInference(inference, domains);
            }
        }
        
        return null;
    }
    
    return backtrack(new Set(), getAllVariables(gameState));
}
```

#### ì ‘ê·¼ë²• 2: í™•ë¥ ì  ì¶”ë¡  (ë² ì´ì§€ì•ˆ)

```javascript
function bayesianInference(gameState) {
    // ì‚¬ì „ í™•ë¥  ì´ˆê¸°í™”
    const priors = initializePriors(gameState);
    
    // ê° ì¶”ì¸¡ì— ê¸°ë°˜í•˜ì—¬ ì‹ ë… ì—…ë°ì´íŠ¸
    for (const guess of gameState.previousGuesses) {
        updateBeliefs(priors, guess, gameState);
    }
    
    // ê°€ì¥ ë†’ì€ ì‚¬í›„ í™•ë¥ ì„ ê°€ì§„ í‚¤ì›Œë“œ ì„ íƒ
    return selectTopK(priors, gameState.answerCount);
}

function updateBeliefs(beliefs, guess, gameState) {
    const likelihood = calculateLikelihood(guess, gameState);
    
    // ë² ì´ì¦ˆ ì •ë¦¬: P(ì •ë‹µ|ì¦ê±°) âˆ P(ì¦ê±°|ì •ë‹µ) * P(ì •ë‹µ)
    for (const [keyword, prior] of beliefs) {
        const posterior = likelihood.get(keyword) * prior;
        beliefs.set(keyword, normalize(posterior));
    }
}
```

#### ì ‘ê·¼ë²• 3: ì •ë³´ ì´ë¡ 

```javascript
function maximizeInformationGain(gameState) {
    const possibleSolutions = generatePossibleSolutions(gameState);
    
    let bestGuess = null;
    let maxInfoGain = -Infinity;
    
    for (const candidate of generateCandidates(gameState)) {
        const infoGain = calculateExpectedInfoGain(candidate, possibleSolutions);
        
        if (infoGain > maxInfoGain) {
            maxInfoGain = infoGain;
            bestGuess = candidate;
        }
    }
    
    return bestGuess;
}

function calculateExpectedInfoGain(guess, possibleSolutions) {
    const outcomeDistribution = new Map();
    
    // ê²°ê³¼ í™•ë¥  ê³„ì‚°
    for (const solution of possibleSolutions) {
        const correctCount = countCorrect(guess, solution);
        outcomeDistribution.set(correctCount, 
            (outcomeDistribution.get(correctCount) || 0) + 1
        );
    }
    
    // ì—”íŠ¸ë¡œí”¼ ê³„ì‚°
    return calculateEntropy(outcomeDistribution, possibleSolutions.length);
}
```

### 3. ê³ ê¸‰ ì „ëµ

#### ì „ëµ 1: ì œê±° ì§‘í•©

í™•ì‹¤í•˜ê²Œ ë¶„ë¥˜í•  ìˆ˜ ìˆëŠ” í‚¤ì›Œë“œ ê·¸ë£¹ ì‹ë³„:

```javascript
function findEliminationSets(gameState) {
    const definiteAnswers = new Set();
    const definiteWrongs = new Set();
    
    // 1ê°œ ì°¨ì´ë¥¼ ê°€ì§„ ì¶”ì¸¡ ìŒ ë¹„êµ
    for (let i = 0; i < gameState.previousGuesses.length; i++) {
        for (let j = i + 1; j < gameState.previousGuesses.length; j++) {
            const [diff1, diff2] = compareGuesses(
                gameState.previousGuesses[i],
                gameState.previousGuesses[j]
            );
            
            if (diff1.length === 1 && diff2.length === 1) {
                // correctCount ì°¨ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¶”ë¡ 
                inferFromDifference(diff1[0], diff2[0], 
                    gameState.previousGuesses[i].correctCount,
                    gameState.previousGuesses[j].correctCount,
                    definiteAnswers, definiteWrongs
                );
            }
        }
    }
    
    return { definiteAnswers, definiteWrongs };
}
```

#### ì „ëµ 2: ê°€ì„¤ ê²€ì¦

í‚¤ì›Œë“œ ì¡°í•©ì— ëŒ€í•œ íŠ¹ì • ê°€ì„¤ í…ŒìŠ¤íŠ¸:

```javascript
function hypothesisTesting(gameState) {
    // ê°€ì„¤ ìƒì„±
    const hypotheses = generateHypotheses(gameState);
    
    // ê° ê°€ì„¤ì„ ê³¼ê±° ë°ì´í„°ë¡œ ê²€ì¦
    const validHypotheses = hypotheses.filter(h => 
        validateHypothesis(h, gameState.previousGuesses)
    );
    
    // ë‚¨ì€ ê°€ì„¤ë“¤ì„ ê°€ì¥ ì˜ êµ¬ë¶„í•˜ëŠ” ì¶”ì¸¡ ì„ íƒ
    return selectDiscriminatingGuess(validHypotheses, gameState);
}
```

#### ì „ëµ 3: ì ì‘í˜• ì „ëµ ì„ íƒ

ê²Œì„ ë‹¨ê³„ì— ë”°ë¼ ì „ëµ ì„ íƒ:

```javascript
function adaptiveStrategy(gameState) {
    const phase = determineGamePhase(gameState);
    
    switch (phase) {
        case 'early':
            // ì •ë³´ ìˆ˜ì§‘ ìµœëŒ€í™”
            return exploratoryStrategy(gameState);
            
        case 'middle':
            // íƒìƒ‰ê³¼ í™œìš©ì˜ ê· í˜•
            return balancedStrategy(gameState);
            
        case 'late':
            // ë‚¨ì€ ì •ë‹µ ì°¾ê¸°ì— ì§‘ì¤‘
            return exploitationStrategy(gameState);
            
        default:
            return defaultStrategy(gameState);
    }
}
```

### 4. êµ¬í˜„ ê°€ì´ë“œë¼ì¸

#### ë©”ëª¨ë¦¬ ê´€ë¦¬

```javascript
// íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡° ì‚¬ìš©
const keywordCache = new Map();
const solutionSpace = new Set();

// ê° í„´ í›„ ì •ë¦¬
function cleanupMemory() {
    // ë¬´íš¨í™”ëœ í•´ ì œê±°
    for (const solution of solutionSpace) {
        if (!isValid(solution)) {
            solutionSpace.delete(solution);
        }
    }
    
    // ìºì‹œ í¬ê¸° ì œí•œ
    if (keywordCache.size > 1000) {
        pruneCache(keywordCache);
    }
}
```

#### ì„±ëŠ¥ ìµœì í™”

```javascript
// ì¡°ê¸° ì¢…ë£Œ
function findSolutionsOptimized(gameState, maxSolutions = 100) {
    const solutions = [];
    const startTime = Date.now();
    
    function search(current, index) {
        // ì‹œê°„ ì œí•œ ê²€ì‚¬
        if (Date.now() - startTime > 1500) return;
        
        // í•´ ê°œìˆ˜ ì œí•œ ê²€ì‚¬
        if (solutions.length >= maxSolutions) return;
        
        // ... ê²€ìƒ‰ ë¡œì§
    }
    
    search([], 0);
    return solutions;
}

// ë©”ëª¨ì´ì œì´ì…˜
const memo = new Map();

function memoizedCalculation(key, computeFn) {
    if (memo.has(key)) {
        return memo.get(key);
    }
    
    const result = computeFn();
    memo.set(key, result);
    return result;
}
```

### 5. ì¼ë°˜ì ì¸ í•¨ì •ê³¼ í•´ê²°ì±…

#### í•¨ì • 1: íƒ€ì„ì•„ì›ƒ ë¬¸ì œ

**ë¬¸ì œ**: ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ì´ ì‹œê°„ ì œí•œ ì´ˆê³¼

**í•´ê²°ì±…**:
```javascript
function makeGuess(gameState) {
    const startTime = Date.now();
    const timeLimit = 1800; // 200ms ë²„í¼ ë‚¨ê¹€
    
    // ë¨¼ì € ê³ ê¸‰ ì „ëµ ì‹œë„
    try {
        const result = advancedStrategy(gameState, timeLimit);
        if (Date.now() - startTime < timeLimit && result) {
            return result;
        }
    } catch (e) {
        console.error('ê³ ê¸‰ ì „ëµ ì‹¤íŒ¨:', e);
    }
    
    // ê°„ë‹¨í•œ ì „ëµìœ¼ë¡œ í´ë°±
    return simpleStrategy(gameState);
}
```

#### í•¨ì • 2: ìœ íš¨í•˜ì§€ ì•Šì€ ì¶”ì¸¡

**ë¬¸ì œ**: ì¤‘ë³µëœ ì¸ë±ìŠ¤ë‚˜ ì˜ëª»ëœ ê°œìˆ˜ ë°˜í™˜

**í•´ê²°ì±…**:
```javascript
function validateGuess(guess, gameState) {
    // ê¸¸ì´ ê²€ì‚¬
    if (guess.length !== gameState.answerCount) {
        throw new Error(`ì˜ëª»ëœ ê¸¸ì´: ${guess.length}`);
    }
    
    // ì¤‘ë³µ ê²€ì‚¬
    if (new Set(guess).size !== guess.length) {
        throw new Error('ì¤‘ë³µëœ ì¸ë±ìŠ¤');
    }
    
    // ë²”ìœ„ ê²€ì‚¬
    for (const idx of guess) {
        if (idx < 0 || idx >= gameState.keywords.length) {
            throw new Error(`ì˜ëª»ëœ ì¸ë±ìŠ¤: ${idx}`);
        }
    }
    
    // íŒíŠ¸ ê²€ì‚¬
    for (const hint of gameState.myHints) {
        if (guess.includes(hint)) {
            throw new Error(`ì¶”ì¸¡ì— íŒíŠ¸ í¬í•¨: ${hint}`);
        }
    }
    
    return true;
}
```

### 6. AI í…ŒìŠ¤íŠ¸í•˜ê¸°

#### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```javascript
// ì œì•½ ë§Œì¡± í…ŒìŠ¤íŠ¸
function testCSP() {
    const testState = {
        keywords: ['a', 'b', 'c', 'd', 'e'],
        myHints: [1],
        answerCount: 3,
        previousGuesses: [
            { guess: [0, 1, 2], correctCount: 2 },
            { guess: [0, 2, 3], correctCount: 3 }
        ]
    };
    
    const result = solveCSP(testState);
    assert(result.includes(0) && result.includes(2) && result.includes(3));
}

// ì—£ì§€ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
function testEdgeCases() {
    // ë¹ˆ ì¶”ì¸¡ ê¸°ë¡
    // ëª¨ë“  íŒíŠ¸
    // í•˜ë‚˜ì˜ ê°€ëŠ¥í•œ í•´
    // ê°€ëŠ¥í•œ í•´ ì—†ìŒ
}
```

#### ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

```javascript
function benchmark() {
    const scenarios = generateTestScenarios();
    const results = [];
    
    for (const scenario of scenarios) {
        const startTime = performance.now();
        const guess = makeGuess(scenario);
        const endTime = performance.now();
        
        results.push({
            scenario: scenario.name,
            time: endTime - startTime,
            valid: validateGuess(guess, scenario)
        });
    }
    
    return results;
}
```

### 7. ì˜ˆì œ ì†”ë£¨ì…˜

#### ì´ˆê¸‰ ì†”ë£¨ì…˜ (ì ìˆ˜: 60-70)

```javascript
function makeGuess(gameState) {
    // ê°„ë‹¨í•œ ë¹ˆë„ ê¸°ë°˜ ì ‘ê·¼ë²•
    const scores = new Map();
    
    // ì ìˆ˜ ì´ˆê¸°í™”
    for (let i = 0; i < gameState.keywords.length; i++) {
        if (!gameState.myHints.includes(i) && 
            !gameState.revealedWrongAnswers.includes(i)) {
            scores.set(i, 0);
        }
    }
    
    // ì¶”ì¸¡ ê¸°ë¡ì— ê¸°ë°˜í•œ ì ìˆ˜ ë¶€ì—¬
    for (const guess of gameState.previousGuesses) {
        const scorePerKeyword = guess.correctCount / guess.guess.length;
        
        for (const idx of guess.guess) {
            if (scores.has(idx)) {
                scores.set(idx, scores.get(idx) + scorePerKeyword);
            }
        }
    }
    
    // ìƒìœ„ ì ìˆ˜ í‚¤ì›Œë“œ ì„ íƒ
    const sorted = Array.from(scores.entries())
        .sort((a, b) => b[1] - a[1])
        .map(entry => entry[0]);
    
    // ê³µê°œëœ ì •ë‹µ í¬í•¨
    const result = [...gameState.revealedAnswers];
    
    for (const idx of sorted) {
        if (result.length >= gameState.answerCount) break;
        if (!result.includes(idx)) {
            result.push(idx);
        }
    }
    
    return result;
}
```

#### ì¤‘ê¸‰ ì†”ë£¨ì…˜ (ì ìˆ˜: 75-85)

```javascript
function makeGuess(gameState) {
    // í™•ì‹¤í•œ ì •ë³´ ì¶”ì¶œ
    const { definiteAnswers, definiteWrongs } = analyzeGuesses(gameState);
    
    // í™•ë¥  ë§µ êµ¬ì¶•
    const probabilities = buildProbabilityMap(gameState, definiteAnswers, definiteWrongs);
    
    // ì¶©ë¶„í•œ í™•ì‹¤í•œ ì •ë‹µì´ ìˆìœ¼ë©´ ì‚¬ìš©
    if (definiteAnswers.size >= gameState.answerCount) {
        return Array.from(definiteAnswers).slice(0, gameState.answerCount);
    }
    
    // ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ í™•ì‹¤í•œ ì •ë‹µê³¼ ê°€ì¥ ë†’ì€ í™•ë¥  í›„ë³´ ê²°í•©
    const guess = Array.from(definiteAnswers);
    const candidates = Array.from(probabilities.entries())
        .filter(([idx, _]) => !definiteAnswers.has(idx))
        .sort((a, b) => b[1] - a[1]);
    
    for (const [idx, _] of candidates) {
        if (guess.length >= gameState.answerCount) break;
        guess.push(idx);
    }
    
    return guess;
}

function analyzeGuesses(gameState) {
    const definiteAnswers = new Set(gameState.revealedAnswers);
    const definiteWrongs = new Set([
        ...gameState.myHints,
        ...gameState.revealedWrongAnswers
    ]);
    
    // ìŒë³„ ë¹„êµ ë¡œì§
    for (let i = 0; i < gameState.previousGuesses.length - 1; i++) {
        for (let j = i + 1; j < gameState.previousGuesses.length; j++) {
            inferFromPair(
                gameState.previousGuesses[i],
                gameState.previousGuesses[j],
                definiteAnswers,
                definiteWrongs
            );
        }
    }
    
    return { definiteAnswers, definiteWrongs };
}
```

#### ê³ ê¸‰ ì†”ë£¨ì…˜ (ì ìˆ˜: 90+)

```javascript
function makeGuess(gameState) {
    // ë‹¨ê³„ ê¸°ë°˜ ì „ëµ ì„ íƒ
    const strategy = selectStrategy(gameState);
    
    switch (strategy) {
        case 'CSP_SOLVER':
            return cspSolver(gameState);
        case 'BAYESIAN':
            return bayesianSolver(gameState);
        case 'INFO_THEORY':
            return infoTheorySolver(gameState);
        default:
            return hybridSolver(gameState);
    }
}

function hybridSolver(gameState) {
    // ì—¬ëŸ¬ ì ‘ê·¼ë²• ê²°í•©
    const cspSolutions = findValidSolutions(gameState, 50);
    
    if (cspSolutions.length === 0) {
        // í™•ë¥ ì  ì ‘ê·¼ë²•ìœ¼ë¡œ í´ë°±
        return bayesianSolver(gameState);
    }
    
    if (cspSolutions.length === 1) {
        // ê³ ìœ í•œ í•´ ë°œê²¬
        return cspSolutions[0];
    }
    
    // ì—¬ëŸ¬ ìœ íš¨í•œ í•´ - ì •ë³´ ì´ë¡  ì‚¬ìš©
    return selectBestGuess(cspSolutions, gameState);
}

function findValidSolutions(gameState, limit) {
    const solutions = [];
    const candidates = generateCandidateSets(gameState);
    
    for (const candidate of candidates) {
        if (solutions.length >= limit) break;
        
        if (satisfiesAllConstraints(candidate, gameState)) {
            solutions.push(candidate);
        }
    }
    
    return solutions;
}

function selectBestGuess(solutions, gameState) {
    // ì •ë³´ ì´ë¡ ì  ì ‘ê·¼
    let bestGuess = null;
    let maxInfoGain = -Infinity;
    
    // ë‹¤ì–‘í•œ ì¶”ì¸¡ ìƒì„±
    const guesses = generateDiverseGuesses(solutions, gameState);
    
    for (const guess of guesses) {
        const infoGain = calculateInfoGain(guess, solutions);
        
        if (infoGain > maxInfoGain) {
            maxInfoGain = infoGain;
            bestGuess = guess;
        }
    }
    
    return bestGuess || solutions[0];
}
```

---

## ëŒ€íšŒ ê·œì¹™

### ì œì¶œ ê°€ì´ë“œë¼ì¸

1. **ì½”ë“œ í˜•ì‹**
   - `makeGuess`ë¼ëŠ” ì´ë¦„ì˜ ë‹¨ì¼ JavaScript í•¨ìˆ˜
   - ì „ì—­ ë³€ìˆ˜ ê¸ˆì§€ (í•„ìš”ì‹œ í´ë¡œì € ì‚¬ìš©)
   - ìµœëŒ€ 10,000ì

2. **í…ŒìŠ¤íŠ¸ ê³¼ì •**
   - ìƒ˜í”Œ ìƒëŒ€ì— ëŒ€í•œ ì˜ˆë¹„ í…ŒìŠ¤íŠ¸
   - ì˜ˆì„  ë¼ìš´ë“œ (ìƒìœ„ 50% ì§„ì¶œ)
   - ë‹¤ì–‘í•œ ìƒëŒ€ì™€ì˜ í† ë„ˆë¨¼íŠ¸ ëŒ€ì§„

3. **ë­í‚¹ ì‹œìŠ¤í…œ**
   - ELO ê¸°ë°˜ ë ˆì´íŒ… ì‹œìŠ¤í…œ
   - ì§€ì—­ë³„ ë° ê¸€ë¡œë²Œ ë¦¬ë”ë³´ë“œ
   - ìƒê¸ˆì´ ìˆëŠ” ì›”ê°„ ì±”í”¼ì–¸ì‹­

### ê³µì • í”Œë ˆì´ ì •ì±…

- ì½”ë“œ ë‚œë…í™” ê¸ˆì§€
- íƒ€ì´ë° ê³µê²©ì´ë‚˜ ì•…ìš© ê¸ˆì§€
- ì¸ìŠ¤í„´ìŠ¤ ê°„ í†µì‹  ê¸ˆì§€
- ìœ„ë°˜ ì‹œ ì‹¤ê²© ì²˜ë¦¬

### ë¦¬ì†ŒìŠ¤

- **ìŠ¤íƒ€í„° í‚¤íŠ¸**: ê¸°ë³¸ AI êµ¬í˜„
- **í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬**: ë¡œì»¬ í…ŒìŠ¤íŠ¸ í™˜ê²½
- **ë¦¬í”Œë ˆì´ ë·°ì–´**: ê²Œì„ ë¶„ì„
- **ì»¤ë®¤ë‹ˆí‹° í¬ëŸ¼**: ì „ëµ í† ë¡  (ì½”ë“œ ê³µìœ  ê¸ˆì§€)

---

## FAQ

**Q: Can I use machine learning libraries?**
A: No, only vanilla JavaScript is allowed. Implement algorithms from scratch.

**Q: How are ties broken?**
A: By efficiency (fewer turns), then by average decision time.

**Q: Can I store state between turns?**
A: No, each turn must be stateless. Use only the provided gameState.

**Q: What happens if my code crashes?**
A: A random valid guess will be made, and you receive a penalty.

**Q: How often can I submit?**
A: Maximum 10 submissions per day, best score counts.

---

## Get Started

1. Read the complete rules and tutorial
2. Download the starter kit
3. Implement your `makeGuess` function
4. Test locally with the provided framework
5. Submit your solution
6. Watch your AI compete!

Good luck, and may the best algorithm win! ğŸ¯